<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bomberman Game</title>
    <link rel="icon" href="/favicon.png" type="image/x-icon">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline';
        style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
        font-src 'self' https://fonts.gstatic.com;
        connect-src 'self' ws:;
    ">
    <style>
        body { 
            display: flex; 
            justify-content: center; 
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #020024, #090979, #00d4ff);
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            position: relative;
        }
        #background-universe {
            position: fixed;
            top: 0;
            left: 0;
            width: 300%;
            height: 300%;
            background: radial-gradient(circle at center, #090979, #020024);
            z-index: -3;
            animation: zoomBackground 60s linear infinite;
        }
        @keyframes zoomBackground {
            from { transform: scale(1); }
            to { transform: scale(1.2); }
        }
        #background-stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: -2;
            pointer-events: none;
            overflow: hidden;
        }
        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            opacity: 0.8;
            animation: twinkle 5s infinite;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.3; }
        }
        /* Generate stars */
        #background-stars::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            background: transparent;
            box-shadow: 
                10px 20px white, 50px 80px white, 100px 150px white,
                200px 300px white, 350px 420px white, 400px 500px white,
                600px 700px white, 750px 820px white, 900px 950px white,
                1100px 1200px white, 1300px 1400px white, 1500px 1600px white,
                1700px 1800px white, 1900px 2000px white;
            animation: moveStars 100s linear infinite;
        }
        #background-stars::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            background: transparent;
            box-shadow: 
                15px 25px white, 55px 85px white, 105px 155px white,
                205px 305px white, 355px 425px white, 405px 505px white,
                605px 705px white, 755px 825px white, 905px 955px white,
                1105px 1210px white, 1310px 1410px white, 1510px 1610px white,
                1710px 1810px white, 1910px 2010px white;
            animation: moveStarsReverse 150s linear infinite;
        }
        @keyframes moveStars {
            from { transform: translate(0, 0); }
            to { transform: translate(-50%, -50%); }
        }
        @keyframes moveStarsReverse {
            from { transform: translate(0, 0); }
            to { transform: translate(50%, 50%); }
        }
        #game-container { 
            display: flex; 
            flex-direction: row; 
            align-items: flex-start;
            width: 100%;
            height: 100%;
            padding: 30px;
            box-sizing: border-box;
            position: relative;
            z-index: 1;
            justify-content: center;
            gap: 30px;
        }
        #chat-container {
            display: flex;
            flex-direction: column;
            width: 300px;
            max-width: 100%;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #00ffff;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.7);
            color: #00ffff;
            height: 650px;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        #chat-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,255,255,0.2) 1px, transparent 1px);
            background-size: 20px 20px;
            animation: moveParticles 60s linear infinite;
            z-index: -1;
        }
        #chat-container h2 {
            margin-bottom: 25px;
            text-align: center;
            color: #00ffff;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 15px #00ffff;
        }
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        .chat-message {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 10px;
            font-size: 14px;
            color: #00ffff;
            text-shadow: 0 0 7px #00ffff;
            animation: fadeInChat 0.5s ease-in-out, fadeoutAndRemove 6s forwards;
        }
        @keyframes fadeInChat {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeoutAndRemove {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
        .chat-message .nickname {
            color: #ff69b4;
            font-weight: bold;
        }
        #chat-input-container {
            display: flex;
            gap: 15px;
        }
        #chat-input {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            outline: none;
            background: rgba(255, 255, 255, 0.1);
            color: #00ffff;
            box-shadow: 0 0 10px rgba(0,255,255,0.7);
            backdrop-filter: blur(5px);
        }
        #chat-send {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background-color: #00ffff;
            color: #000;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 10px rgba(0,255,255,0.7);
            backdrop-filter: blur(5px);
        }
        #chat-send:hover {
            background-color: #00cccc;
            transform: scale(1.05);
        }
        #game-area { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            flex: 1;
            position: relative;
            perspective: 1000px;
        }
        #game { 
            display: grid;
            grid-template-columns: repeat(15, 50px);
            grid-template-rows: repeat(15, 50px);
            gap: 3px;
            width: 800px;
            height: 800px;
            background-color: #0d0d0d;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.7);
            border-radius: 15px;
        }
        /* Define the cell styles */
        .cell {
            width: 50px;
            height: 50px;
            position: relative;
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: inset 0 0 10px rgba(255,255,255,0.1);
        }

        .empty-space { 
            background-color: #1a1a1a; 
            box-shadow: inset 0 0 10px #333;
        }

        /* Brick walls and indestructible walls */
        .brick-wall {
            background-image: url('/brick_wall_texture.png');
            background-size: cover;
            animation: pulsateBrick 3s infinite;
        }
        @keyframes pulsateBrick {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .indestructible-wall {
            background-color: #004d00;
            box-shadow: 0 0 15px #00FF99;
            animation: scaleWall 6s ease-in-out infinite;
        }
        @keyframes scaleWall {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Power-up icons will be images inside the cell */
        .power-up-icon {
            position: absolute;
            width: 35px;
            height: 35px;
            top: 7.5px;
            left: 7.5px;
            z-index: 1;
            pointer-events: none;
            animation: glowPowerUp 2s ease-in-out infinite alternate;
        }
        @keyframes glowPowerUp {
            from { filter: brightness(1); }
            to { filter: brightness(1.5); }
        }

        /* Adjust player image size and positioning */
        .player {
            position: absolute;
            width: 45px;
            height: 45px;
            z-index: 2;
            top: 2.5px;
            left: 2.5px;
            transition: transform 0.1s;
            filter: drop-shadow(0 0 15px #00ffff);
            animation: floatPlayer 3s ease-in-out infinite;
        }
        @keyframes floatPlayer {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }

        /* Player name above head */
        .player-name {
            position: absolute;
            top: -22px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            color: #00ffff;
            padding: 3px 7px;
            border-radius: 7px;
            font-size: 14px;
            white-space: nowrap;
            pointer-events: none;
            text-shadow: 0 0 7px #00ffff;
            z-index: 3;
            transition: text-shadow 0.3s, color 0.3s;
        }

        .player-name.first-place {
            color: gold;
            text-shadow: 0 0 15px gold, 0 0 25px gold, 0 0 35px gold;
        }

        /* Flash effect when player is hit */
        .player.hit {
            animation: flashRed 5s;
        }
        @keyframes flashRed {
            0% { filter: brightness(1); }
            50% { filter: brightness(0.5) sepia(1) hue-rotate(-50deg); }
            100% { filter: brightness(1); }
        }

        /* Explosion effect */
        .explosion-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 50px;
            height: 50px;
            background-image: url('/explosion_sprite.png');
            background-size: cover;
            background-position: center;
            z-index: 4;
            opacity: 0.8;
            pointer-events: none;
            animation: explode 1.5s forwards;
        }
        @keyframes explode {
            0% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1.5); }
            100% { opacity: 0; transform: scale(2); }
        }

        /* Bomb image size and positioning */
        .bomb {
            position: absolute;
            width: 50px;
            height: 50px;
            z-index: 1;
            top: 0px;
            left: 0px;
            animation: blinkBomb 1.5s infinite;
        }
        @keyframes blinkBomb {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        #status {
            margin-top: 15px;
            font-size: 20px;
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff;
            animation: pulseStatus 2s infinite;
        }
        @keyframes pulseStatus {
            0%, 100% { text-shadow: 0 0 15px #00ffff; }
            50% { text-shadow: 0 0 25px #00ffff; }
        }

        /* Updated styles for the player list */
        #player-list {
            display: flex;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #00ffff;
            padding: 25px;
            border-radius: 20px;
            width: 300px;
            max-width: 100%;
            height: 650px;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.7);
            color: #00ffff;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        #player-list::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,255,255,0.2) 1px, transparent 1px);
            background-size: 20px 20px;
            animation: moveParticles 60s linear infinite;
            z-index: -1;
        }
        #player-list h2 {
            margin-bottom: 25px;
            text-align: center;
            color: #00ffff;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 15px #00ffff;
        }
        #player-list ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
            flex: 1;
        }
        #player-list li {
            margin-bottom: 20px;
            font-size: 18px;
            display: flex;
            align-items: center;
            color: #ffffff;
            text-shadow: 0 0 7px #00ffff;
            animation: slideIn 0.5s ease-in-out;
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        #player-list li img.player-icon {
            width: 35px;
            height: 35px;
            margin-right: 10px;
            filter: drop-shadow(0 0 7px #00ffff);
        }
        #player-list li img.trophy {
            width: 45px;
            height: 45px;
            margin-left: 10px;
            animation: scaleTrophy 4s ease-in-out infinite;
        }
        @keyframes scaleTrophy {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        /* Styles for the message container and messages */
        #message-container {
            margin-top: 15px;
            width: 100%;
            text-align: left;
            position: relative;
            max-height: 180px;
            overflow-y: auto;
            flex: 0 0 auto;
        }
        .game-message {
            display: block;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            margin: 10px 0;
            border-radius: 10px;
            animation: fadeoutMessage 6s forwards;
            font-size: 16px;
            color: #00ffff;
            text-shadow: 0 0 7px #00ffff;
            backdrop-filter: blur(5px);
        }
        @keyframes fadeoutMessage {
            0% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(-10px); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* Optional: Enhanced styling for hit messages */
        .game-message.hit-message {
            background: rgba(255, 0, 0, 0.8);
            color: #fff;
            font-weight: bold;
            animation: shakeFade 6s forwards;
            text-shadow: 0 0 15px #ff0000;
        }
        @keyframes shakeFade {
            0% { opacity: 1; transform: translateX(0); }
            10% { transform: translateX(-5px); }
            20% { transform: translateX(5px); }
            30% { transform: translateX(-5px); }
            40% { transform: translateX(5px); }
            50% { transform: translateX(-5px); }
            60% { transform: translateX(5px); }
            70% { transform: translateX(-5px); }
            80% { opacity: 0.5; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(0); }
        }

        /* Styles for the nickname overlay */
        #nickname-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeInOverlay 1s ease-in-out forwards;
        }
        @keyframes fadeInOverlay {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #nickname-prompt {
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 25px;
            text-align: center;
            box-shadow: 0 0 40px rgba(0,255,255,0.7);
            animation: zoomInPrompt 0.5s ease-in-out forwards;
        }
        @keyframes zoomInPrompt {
            from { transform: scale(0.5); }
            to { transform: scale(1); }
        }
        #nickname-prompt h2 {
            margin-bottom: 30px;
            color: #00ffff;
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            text-shadow: 0 0 15px #00ffff;
        }
        #nickname-prompt input {
            width: 85%;
            padding: 18px;
            margin-bottom: 20px;
            border: none;
            border-radius: 12px;
            font-size: 20px;
            outline: none;
            background: rgba(255, 255, 255, 0.1);
            color: #00ffff;
            box-shadow: 0 0 15px rgba(0,255,255,0.7);
            backdrop-filter: blur(5px);
            animation: glowInputField 2s ease-in-out infinite alternate;
        }
        @keyframes glowInputField {
            from { box-shadow: 0 0 10px rgba(0,255,255,0.5); }
            to { box-shadow: 0 0 20px rgba(0,255,255,1); }
        }
        #nickname-prompt button {
            padding: 14px 30px;
            border: none;
            background-color: #00ffff;
            color: #000;
            border-radius: 12px;
            font-size: 20px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 15px rgba(0,255,255,0.7);
            backdrop-filter: blur(5px);
        }
        #nickname-prompt button:hover {
            background-color: #00cccc;
            transform: scale(1.07);
        }

        /* Connection Refused Error Overlay */
        #error-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeInError 0.5s ease-in-out forwards;
        }
        @keyframes fadeInError {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #error-message-box {
            background: rgba(0, 0, 0, 0.85);
            padding: 50px;
            border-radius: 25px;
            text-align: center;
            box-shadow: 0 0 40px rgba(0,255,255,0.7);
            animation: zoomInError 0.5s ease-in-out forwards;
        }
        @keyframes zoomInError {
            from { transform: scale(0.5); }
            to { transform: scale(1); }
        }
        #error-message-box h2 {
            margin-bottom: 25px;
            color: #ff4d4d;
            font-family: 'Orbitron', sans-serif;
            font-size: 36px;
            text-shadow: 0 0 15px #ff4d4d;
        }
        #error-message-box p {
            color: #ffffff;
            font-size: 20px;
            text-shadow: 0 0 7px #00ffff;
        }
        #error-message-box button {
            margin-top: 25px;
            padding: 14px 30px;
            border: none;
            background-color: #00ffff;
            color: #000;
            border-radius: 12px;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 10px rgba(0,255,255,0.7);
            backdrop-filter: blur(5px);
        }
        #error-message-box button:hover {
            background-color: #00cccc;
            transform: scale(1.07);
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            #game {
                grid-template-columns: repeat(15, 45px);
                grid-template-rows: repeat(15, 45px);
                width: 675px;
                height: 675px;
            }
            .cell {
                width: 45px;
                height: 45px;
            }
            .player {
                width: 38px;
                height: 38px;
            }
            .bomb {
                width: 40px;
                height: 40px;
            }
            #player-list {
                width: 250px;
                padding: 20px;
            }
            #nickname-prompt {
                padding: 30px;
            }
            #nickname-prompt h2 {
                font-size: 28px;
            }
            #nickname-prompt input {
                width: 90%;
                padding: 15px;
                font-size: 18px;
            }
            #nickname-prompt button {
                padding: 12px 25px;
                font-size: 18px;
            }
        }

        @media (max-width: 768px) {
            #game-container {
                flex-direction: column;
                align-items: center;
                padding: 15px;
            }
            #game {
                grid-template-columns: repeat(15, 35px);
                grid-template-rows: repeat(15, 35px);
                width: 525px;
                height: 525px;
            }
            .cell {
                width: 35px;
                height: 35px;
            }
            .player {
                width: 28px;
                height: 28px;
            }
            .bomb {
                width: 32px;
                height: 32px;
            }
            #player-list {
                width: 100%;
                margin-left: 0;
                margin-top: 25px;
                height: 450px;
            }
            #chat-container {
                width: 100%;
                margin-right: 0;
                margin-bottom: 25px;
                height: 350px;
            }
            #status {
                font-size: 18px;
            }
        }
        
        /* Futuristic Glowing Text */
        .glow-text {
            color: #00ffff;
            text-shadow: 0 0 15px #00ffff, 0 0 25px #00ffff, 0 0 35px #00ffff, 0 0 45px #00ffff;
            font-family: 'Orbitron', sans-serif;
        }

        /* Glowing Buttons */
        button {
            border: none;
            outline: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        /* Particle Movement */
        @keyframes moveParticles {
            from { background-position: 0 0; }
            to { background-position: 100px 100px; }
        }
    </style>
    <!-- Google Fonts for Orbitron -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

<div id="background-universe"></div>
<div id="background-stars"></div>

<div id="game-container">
    <div id="chat-container">
        <h2>Chat</h2>
        <div id="chat-messages"></div>
        <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Type your message..." maxlength="100">
            <button id="chat-send">SEND</button>
        </div>
    </div>
    <div id="game-area">
        <div id="game"></div>
        <div id="status" class="glow-text">Game started! Use arrow keys to move. Press space to drop a bomb.</div>
    </div>
    <div id="player-list">
        <h2>Players</h2>
        <ul id="players"></ul>
        <h2>Messages</h2>
        <div id="message-container"></div>
    </div>
</div>

<!-- Connection Refused Error Overlay -->
<div id="error-overlay">
    <div id="error-message-box">
        <h2 class="glow-text">Connection Refused</h2>
        <p class="glow-text">Too many connections from your IP. Please close the game on one of the computers on the same network first.</p>
        <button id="error-retry">Retry</button>
    </div>
</div>

<!-- Audio elements for sound effects -->
<audio id="powerup-sound" src="/powerup_sound.mp3"></audio>
<audio id="bomb-explosion-sound" src="/bomb_explosion.mp3"></audio>
<audio id="hit-sound" src="/hit_sound.wav"></audio>

<!-- Nickname Overlay -->
<div id="nickname-overlay">
    <div id="nickname-prompt">
        <h2 class="glow-text">Enter Your Nickname</h2>
        <input type="text" id="nickname-input" maxlength="20" placeholder="Nickname">
        <button id="nickname-submit" class="glow-text">Join Game</button>
    </div>
</div>

<script>
    let ws;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    const reconnectDelay = 3000; // 3 seconds
    const gameElement = document.getElementById('game');
    const statusElement = document.getElementById('status');
    const playerListElement = document.getElementById('players');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    const errorOverlay = document.getElementById('error-overlay');
    const errorRetryButton = document.getElementById('error-retry');

    let map = []; // Will be initialized from server
    let powerUps = {}; // Positions of power-ups

    let playerId;
    let password;
    const players = {};
    const playerImages = {}; // Mapping of playerId to image name
    let nickname;

    let keysPressed = {};
    let movementInterval = null;
    let movementSpeed = 300; // milliseconds per movement step

    let firstPlaceId = null;

    const playerElements = {}; // Cache for player DOM elements

    let connectionRefused = false;

    function escapeHtml(unsafe) {
        return unsafe.replace(/[&<"'>]/g, function(m) {
            switch (m) {
                case '&': return '&amp;';
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '"': return '&quot;';
                case "'": return '&#039;';
                default: return m;
            }
        });
    }

    function initializeGameGrid() {
        gameElement.innerHTML = ''; // Clear existing grid
        for (let row = 0; row < map.length; row++) {
            for (let col = 0; col < map[row].length; col++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');

                if (map[row][col] === 1) {
                    cell.classList.add('brick-wall');
                } else if (map[row][col] === 0) {
                    cell.classList.add('empty-space');
                } else if (map[row][col] === 2) {
                    cell.classList.add('indestructible-wall');
                } else if (map[row][col] === 3) {
                    cell.classList.add('empty-space');

                    // Create an img element for the power-up
                    const powerUpKey = `${col},${row}`;
                    const powerUpType = powerUps[powerUpKey];

                    const powerUpElement = document.createElement('img');
                    powerUpElement.classList.add('power-up-icon');

                    if (powerUpType === 'bombCapacity') {
                        powerUpElement.src = '/power_up_max_bombs.png';
                    } else if (powerUpType === 'blastRadius') {
                        powerUpElement.src = '/power_up_extra_blast_radius.png';
                    } else if (powerUpType === 'speed') {
                        powerUpElement.src = '/speed_powerup.png';
                    }

                    cell.appendChild(powerUpElement);
                }
                gameElement.appendChild(cell);
            }
        }
    }

    function clearAllBombs() {
        const bombElements = document.querySelectorAll('.bomb');
        bombElements.forEach(bomb => bomb.remove());
    }

    function isWalkable(x, y) {
        if (x < 0 || x >= 15 || y < 0 || y >= 15) return false;

        const tile = map[y][x];
        // Check if there's a bomb at this position
        const cell = gameElement.children[y * 15 + x];
        const hasBomb = cell.querySelector('.bomb');
        // Return true if tile is empty, a power-up, and there's no bomb
        return (tile === 0 || tile === 3) && !hasBomb;
    }

    function addOrUpdatePlayerListItem(player) {
        let listItem = playerListElement.querySelector(`li[data-player-id="${player.id}"]`);
        if (listItem) {
            updatePlayerListItem(player, listItem);
        } else {
            listItem = document.createElement('li');
            listItem.setAttribute('data-player-id', player.id);
            listItem.classList.add('glow-text');
            updatePlayerListItem(player, listItem);
            playerListElement.appendChild(listItem);
        }
    }

    function updatePlayerListItem(player, listItem) {
        listItem.innerHTML = ''; // Clear existing content

        // Create player icon
        const playerIcon = document.createElement('img');
        playerIcon.src = `/${playerImages[player.id] || 'default_player'}.png`;
        playerIcon.alt = `Player ${player.playerNumber}`;
        playerIcon.classList.add('player-icon');
        listItem.appendChild(playerIcon);

        // Add trophy based on rank
        const index = Array.from(playerListElement.children).indexOf(listItem);
        if (index === 0) {
            const trophy = document.createElement('img');
            trophy.src = '/tropheegold.png';
            trophy.alt = 'Gold Trophy';
            trophy.classList.add('trophy');
            listItem.appendChild(trophy);
        } else if (index === 1) {
            const trophy = document.createElement('img');
            trophy.src = '/tropheesilver.png';
            trophy.alt = 'Silver Trophy';
            trophy.classList.add('trophy');
            listItem.appendChild(trophy);
        } else if (index === 2) {
            const trophy = document.createElement('img');
            trophy.src = '/tropheebronze.png';
            trophy.alt = 'Bronze Trophy';
            trophy.classList.add('trophy');
            listItem.appendChild(trophy);
        }

        const safeNickname = escapeHtml(player.nickname || `Player ${player.playerNumber || player.id}`);
        const textNode = document.createTextNode(` ${safeNickname}: ${player.score} points`);
        listItem.appendChild(textNode);
    }

    function removePlayerListItem(playerId) {
        const listItem = playerListElement.querySelector(`li[data-player-id="${playerId}"]`);
        if (listItem) {
            listItem.remove();
        }
    }

    function updatePlayerList(playersData) {
        if (!playersData || typeof playersData !== 'object') {
            console.error("Invalid playersData:", playersData);
            return;
        }

        const playersArray = Object.entries(playersData).map(([pid, player]) => ({ id: pid, ...player }));
        // Sort players by score descending
        playersArray.sort((a, b) => b.score - a.score);

        const currentPlayerIds = new Set(playersArray.map(player => player.id));
        const existingPlayerIds = new Set(Array.from(playerListElement.querySelectorAll('li')).map(li => li.getAttribute('data-player-id')));

        // Remove players not in the new list
        existingPlayerIds.forEach(pid => {
            if (!currentPlayerIds.has(pid)) {
                removePlayerListItem(pid);
            }
        });

        // Add or update players
        playersArray.forEach(player => {
            addOrUpdatePlayerListItem(player);
        });

        // Update first place
        // Remove 'first-place' from the previous first player
        if (firstPlaceId) {
            const previousFirstPlayerName = document.querySelector(`.cell .${firstPlaceId}-name`);
            if (previousFirstPlayerName) {
                previousFirstPlayerName.classList.remove('first-place');
            }
        }

        // Update first place player
        const firstPlayer = playersArray[0];
        if (firstPlayer) {
            const newFirstPlayerName = document.querySelector(`.cell .${firstPlayer.id}-name`);
            if (newFirstPlayerName) {
                newFirstPlayerName.classList.add('first-place');
            }
            firstPlaceId = firstPlayer.id;
        }

        // Reorder the list to match the sorted players
        playersArray.forEach((player, index) => {
            const listItem = playerListElement.querySelector(`li[data-player-id="${player.id}"]`);
            if (listItem && playerListElement.children[index] !== listItem) {
                playerListElement.insertBefore(listItem, playerListElement.children[index]);
            }
        });
    }

    function updatePlayerPosition(pid, x, y, direction = 'down') {
        if (!players[pid]) {
            players[pid] = {};
        }

        // Remove existing player sprite and name from cache
        if (playerElements[pid]) {
            playerElements[pid].image.remove();
            playerElements[pid].name.remove();
        }

        // Calculate the index in the grid
        const index = y * 15 + x;
        const cell = gameElement.children[index];

        if (!cell) {
            console.error(`Cell at index ${index} is undefined. x: ${x}, y: ${y}`);
            return;
        }

        // Map 'ArrowUp' to 'up', etc.
        const directionMap = {
            'ArrowUp': 'up',
            'ArrowDown': 'down',
            'ArrowLeft': 'left',
            'ArrowRight': 'right'
        };

        const mappedDirection = directionMap[direction] || direction;

        const playerElement = document.createElement('img');
        // Use the mapped image name
        const imageName = playerImages[pid] ? playerImages[pid] : 'default_player';
        playerElement.src = `/${imageName}_${mappedDirection}.png`;
        playerElement.classList.add('player', pid, 'glow-text');
        cell.appendChild(playerElement);

        // Add player name
        const playerName = document.createElement('div');
        playerName.classList.add('player-name', `${pid}-name`);
        playerName.textContent = players[pid].nickname || `Player ${players[pid].playerNumber || pid}`;
        cell.appendChild(playerName);

        // If this player is first place, add the 'first-place' class
        if (pid === firstPlaceId) {
            playerName.classList.add('first-place');
        }

        // Cache the player elements
        playerElements[pid] = {
            image: playerElement,
            name: playerName
        };

        // Update local player state
        players[pid].x = x;
        players[pid].y = y;
        players[pid].direction = mappedDirection;
    }

    function removePlayer(pid) {
        if (playerElements[pid]) {
            playerElements[pid].image.remove();
            playerElements[pid].name.remove();
            delete playerElements[pid];
        }
        delete players[pid];
    }

    function placeBomb(x, y) {
        const index = y * 15 + x;
        const cell = gameElement.children[index];

        if (!cell) {
            console.error(`Cell at index ${index} is undefined. x: ${x}, y: ${y}`);
            return;
        }

        const bombElement = document.createElement('img');
        bombElement.src = '/bomb_sprite.png';
        bombElement.classList.add('bomb', 'glow-text');
        cell.appendChild(bombElement);
    }

    function explodeBomb(x, y, destroyedBricks, newPowerUps, explosionPositions) {
        // Remove bomb sprite at the center
        const index = y * 15 + x;
        const cell = gameElement.children[index];
        const bombElement = cell.querySelector('.bomb');
        if (bombElement) {
            bombElement.remove();
        }

        // Play bomb explosion sound
        const bombExplosionSound = document.getElementById('bomb-explosion-sound');
        if (bombExplosionSound) {
            bombExplosionSound.currentTime = 0; // Rewind to start
            bombExplosionSound.play();
        }

        // Display explosion effect in all positions
        explosionPositions.forEach(pos => {
            const idx = pos.y * 15 + pos.x;
            const explosionCell = gameElement.children[idx];

            if (!explosionCell) {
                console.error(`Cell at index ${idx} is undefined. x: ${pos.x}, y: ${pos.y}`);
                return;
            }

            // Display explosion effect
            displayExplosion(explosionCell);

            // If the tile was a brick wall, update it
            if (map[pos.y][pos.x] === 1) {
                map[pos.y][pos.x] = 0;
                explosionCell.classList.remove('brick-wall');
                explosionCell.classList.add('empty-space');
            }

            // Remove bomb sprites in the explosion area
            const bombInCell = explosionCell.querySelector('.bomb');
            if (bombInCell) {
                bombInCell.remove();
            }
        });

        // Handle new power-ups
        newPowerUps.forEach(powerUp => {
            const idx = powerUp.y * 15 + powerUp.x;
            const powerUpCell = gameElement.children[idx];
            const powerUpKey = `${powerUp.x},${powerUp.y}`;
            powerUps[powerUpKey] = powerUp.type; // Update powerUps object
            map[powerUp.y][powerUp.x] = 0; // Update map array

            // Remove any existing classes (e.g., empty-space)
            powerUpCell.className = 'cell empty-space';

            // Create an img element for the power-up icon
            const powerUpElement = document.createElement('img');
            powerUpElement.classList.add('power-up-icon');

            if (powerUp.type === 'bombCapacity') {
                powerUpElement.src = '/power_up_max_bombs.png';
            } else if (powerUp.type === 'blastRadius') {
                powerUpElement.src = '/power_up_extra_blast_radius.png';
            } else if (powerUp.type === 'speed') {
                powerUpElement.src = '/speed_powerup.png';
            }

            powerUpCell.appendChild(powerUpElement);
        });
    }

    function displayExplosion(cell) {
        const explosionElement = document.createElement('div');
        explosionElement.classList.add('explosion-effect');
        cell.appendChild(explosionElement);
        setTimeout(() => {
            explosionElement.remove();
        }, 1500);
    }

    function startMovement() {
        if (movementInterval) return;
        movementInterval = setInterval(() => {
            if (Object.keys(keysPressed).length === 0) {
                stopMovement();
                return;
            }
            let direction = null;
            if (keysPressed['ArrowUp']) direction = 'ArrowUp';
            else if (keysPressed['ArrowDown']) direction = 'ArrowDown';
            else if (keysPressed['ArrowLeft']) direction = 'ArrowLeft';
            else if (keysPressed['ArrowRight']) direction = 'ArrowRight';

            if (direction) {
                // Calculate new position
                let newX = players[playerId].x;
                let newY = players[playerId].y;

                if (direction === 'ArrowUp') newY--;
                if (direction === 'ArrowDown') newY++;
                if (direction === 'ArrowLeft') newX--;
                if (direction === 'ArrowRight') newX++;

                if (isWalkable(newX, newY)) {
                    // Send move message
                    ws.send(JSON.stringify({ type: 'move', direction: direction, playerId: playerId, password: password }));
                }
            }
        }, movementSpeed);
    }

    function stopMovement() {
        if (movementInterval) {
            clearInterval(movementInterval);
            movementInterval = null;
        }
    }

    function updatePlayerSpeed() {
        const player = players[playerId];
        if (!player) return;

        if (player.speed === 1) {
            movementSpeed = 300;
        } else if (player.speed === 2) {
            movementSpeed = 269;
        } else if (player.speed === 3) {
            movementSpeed = 238;
        } else if (player.speed >= 4) {
            movementSpeed = 206;
        }
        // Restart movement interval to apply new speed
        if (movementInterval) {
            stopMovement();
            startMovement();
        }
    }

    function showMessage(text) {
        const messageContainer = document.getElementById('message-container');
        const messageElement = document.createElement('div');
        messageElement.classList.add('game-message');

        const nicknameSpan = document.createElement('span');
        nicknameSpan.classList.add('nickname');
        nicknameSpan.textContent = `${text.includes('You') ? 'You' : 'Player'}: `;

        messageElement.appendChild(nicknameSpan);
        messageElement.appendChild(document.createTextNode(text));

        messageContainer.appendChild(messageElement);
        messageContainer.scrollTop = messageContainer.scrollHeight;

        messageElement.addEventListener('animationend', () => {
            messageElement.remove();
        });
    }

    function showErrorOverlay() {
        errorOverlay.style.display = 'flex';
    }

    function hideErrorOverlay() {
        errorOverlay.style.display = 'none';
    }

    function joinGame() {
        // Extract password from URL
        const urlParts = window.location.pathname.split('/');
        password = urlParts[urlParts.length - 1];

        // Retrieve or generate a unique playerId using sessionStorage
        playerId = sessionStorage.getItem('playerId');
        if (!playerId) {
            playerId = 'player-' + Math.random().toString(36).substr(2, 9);
            sessionStorage.setItem('playerId', playerId);
        }

        if (ws && ws.readyState !== WebSocket.CLOSED) {
            ws.close();
        }

        // Determine the correct WebSocket protocol
        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        ws = new WebSocket(`${protocol}://${window.location.host}`);
        ws.onopen = () => {
            ws.send(JSON.stringify({ type: 'join', playerId: playerId, password: password, nickname: nickname }));
            reconnectAttempts = 0;
            statusElement.textContent = "Connected to Bomberman!";
        };

        ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            if (message.type === 'start') {
                // Store your player number
                if (message.playerNumber) {
                    const imageName = message.playerNumber ? `player${message.playerNumber}` : 'default_player';
                    playerImages[playerId] = imageName;
                }

                // Initialize map and power-ups
                map = message.map;
                powerUps = {};
                message.powerUps.forEach(powerUp => {
                    const powerUpKey = `${powerUp.x},${powerUp.y}`;
                    powerUps[powerUpKey] = powerUp.type;
                });
                initializeGameGrid();

                // Update positions of all players
                for (const pid in message.players) {
                    const player = message.players[pid];
                    // Map other players' IDs to image names
                    const imageName = player.playerNumber ? `player${player.playerNumber}` : 'default_player';
                    playerImages[pid] = imageName;
                    updatePlayerPosition(pid, player.x, player.y, 'down');
                    players[pid] = players[pid] || {};
                    players[pid].speed = player.speed || 1;
                    players[pid].nickname = player.nickname || `Player ${player.playerNumber || pid}`;
                }

                // Update player list
                if (message.players && typeof message.players === 'object') {
                    updatePlayerList(message.players);
                }

                // Update movement speed
                updatePlayerSpeed();

            } else if (message.type === 'newMap') {
                // Clear existing bombs
                clearAllBombs();

                // Handle new map
                map = message.map;
                powerUps = {};
                if (message.powerUps && Array.isArray(message.powerUps)) {
                    message.powerUps.forEach(powerUp => {
                        const powerUpKey = `${powerUp.x},${powerUp.y}`;
                        powerUps[powerUpKey] = powerUp.type;
                    });
                }
                initializeGameGrid();

                // Update players' positions and reset local player properties
                if (message.players && typeof message.players === 'object') {
                    for (const pid in message.players) {
                        const player = message.players[pid];
                        const imageName = player.playerNumber ? `player${player.playerNumber}` : 'default_player';
                        playerImages[pid] = imageName;
                        players[pid] = players[pid] || {};
                        players[pid].x = player.x;
                        players[pid].y = player.y;
                        players[pid].speed = player.speed || 1;
                        players[pid].nickname = player.nickname || `Player ${player.playerNumber || pid}`;
                        updatePlayerPosition(pid, player.x, player.y, 'down');
                    }

                    // Update movement speed
                    updatePlayerSpeed();

                    // Update player list
                    updatePlayerList(message.players);

                    // Show the new map message
                    showMessage("A new map has been generated!");
                } else {
                    console.error("Invalid playersData in newMap:", message.players);
                }
            } else if (message.type === 'update') {
                if (message.playerId && typeof message.x === 'number' && typeof message.y === 'number') {
                    updatePlayerPosition(message.playerId, message.x, message.y, message.direction);
                    if (message.players && typeof message.players === 'object') {
                        updatePlayerList(message.players);
                    }
                }
            } else if (message.type === 'newPlayer') {
                // Map new player's ID to image names
                const newPlayerId = message.playerId;
                const imageName = message.playerNumber ? `player${message.playerNumber}` : 'default_player';
                playerImages[newPlayerId] = imageName;
                updatePlayerPosition(newPlayerId, message.x, message.y, 'down');

                // Store nickname
                players[newPlayerId] = players[newPlayerId] || {};
                players[newPlayerId].nickname = message.nickname || `Player ${message.playerNumber || newPlayerId}`;

                // Update player list
                if (message.players && typeof message.players === 'object') {
                    updatePlayerList(message.players);
                }

            } else if (message.type === 'playerLeft') {
                if (message.playerId) {
                    removePlayer(message.playerId);
                }
                // Update player list
                if (message.players && typeof message.players === 'object') {
                    updatePlayerList(message.players);
                }
            } else if (message.type === 'bombPlaced') {
                if (typeof message.x === 'number' && typeof message.y === 'number') {
                    placeBomb(message.x, message.y);
                }
            } else if (message.type === 'bombExploded') {
                if (typeof message.x === 'number' && typeof message.y === 'number' &&
                    Array.isArray(message.destroyedBricks) && Array.isArray(message.newPowerUps) &&
                    Array.isArray(message.explosionPositions)) {
                    explodeBomb(
                        message.x,
                        message.y,
                        message.destroyedBricks,
                        message.newPowerUps,
                        message.explosionPositions
                    );
                }
            } else if (message.type === 'playerHit') {
                const victimId = message.playerId;
                const attackerId = message.by;
                const victimNickname = players[victimId] ? escapeHtml(players[victimId].nickname || `Player ${players[victimId].playerNumber || victimId}`) : 'Unknown';
                const attackerNickname = attackerId && players[attackerId] ? escapeHtml(players[attackerId].nickname || `Player ${attackerId}`) : 'Unknown';
                
                // Update player position
                if (message.x !== undefined && message.y !== undefined) {
                    updatePlayerPosition(victimId, message.x, message.y, 'down');
                }
                
                // Display appropriate message
                if (victimId === playerId) {
                    if (attackerId === playerId) {
                        showMessage(`You blew yourself up!`);
                    } else {
                        showMessage(`You were hit by ${attackerNickname}!`);
                    }
                } else {
                    if (attackerId === victimId) {
                        showMessage(`${victimNickname} blew themselves up!`);
                    } else {
                        showMessage(`${victimNickname} was hit by ${attackerNickname}!`);
                    }
                }
                
                // Trigger visual effects for the victim
                triggerPlayerHitEffect(victimId);

                // Update player list in case scores changed
                if (message.players && typeof message.players === 'object') {
                    updatePlayerList(message.players);
                }
            } else if (message.type === 'powerUpCollected') {
                if (typeof message.x === 'number' && typeof message.y === 'number') {
                    const idx = message.y * 15 + message.x;
                    const cell = gameElement.children[idx];
                    const powerUpKey = `${message.x},${message.y}`;
                    delete powerUps[powerUpKey]; // Remove from powerUps object
                    map[message.y][message.x] = 0; // Update map array

                    // Remove power-up icon from the cell
                    const powerUpElement = cell.querySelector('.power-up-icon');
                    if (powerUpElement) {
                        powerUpElement.remove();
                    }

                    // Play power-up sound
                    const powerupSound = document.getElementById('powerup-sound');
                    if (powerupSound) {
                        powerupSound.currentTime = 0;
                        powerupSound.play();
                    }
                }
            } else if (message.type === 'chat') {
                if (message.nickname && message.message) {
                    const chatMsg = document.createElement('div');
                    chatMsg.classList.add('chat-message');

                    const nicknameSpan = document.createElement('span');
                    nicknameSpan.classList.add('nickname');
                    nicknameSpan.textContent = `${message.nickname}: `;

                    chatMsg.appendChild(nicknameSpan);
                    chatMsg.appendChild(document.createTextNode(message.message));

                    chatMessages.appendChild(chatMsg);
                    chatMessages.scrollTop = chatMessages.scrollHeight;

                    chatMsg.addEventListener('animationend', () => {
                        chatMsg.remove();
                    });
                }
            } else if (message.type === 'updatePlayerList') {
                if (message.players && typeof message.players === 'object') {
                    updatePlayerList(message.players);
                    // Update player's speed
                    if (players[playerId] && message.players[playerId]) {
                        players[playerId].speed = message.players[playerId].speed || 1;
                        updatePlayerSpeed();
                    }
                }
            }
            // Handle other message types as needed
        };

        // Error handling for WebSocket
        ws.onerror = (error) => console.error("WebSocket error:", error);

        ws.onclose = (event) => {
            if (event.code === 4001) { // Maximum connections per IP exceeded
                connectionRefused = true;
                showErrorOverlay();
            } else {
                if (reconnectAttempts < maxReconnectAttempts && !connectionRefused) {
                    reconnectAttempts++;
                    setTimeout(joinGame, reconnectDelay * Math.pow(2, reconnectAttempts));
                } else {
                    console.error("Max reconnection attempts reached.");
                    statusElement.textContent = "Connection lost. Unable to reconnect.";
                }
            }
        };

        // Event listeners for key presses
        document.addEventListener('keydown', (event) => {
            // Check if chat input is focused
            if (document.activeElement === chatInput) {
                return;
            }

            if (event.key === ' ') {
                event.preventDefault();
                // Send placeBomb message
                ws.send(JSON.stringify({ type: 'placeBomb', playerId: playerId, password: password }));
            } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                if (!keysPressed[event.key]) {
                    event.preventDefault();
                    keysPressed[event.key] = true;
                    // Send move immediately
                    ws.send(JSON.stringify({ type: 'move', direction: event.key, playerId: playerId, password: password }));
                    startMovement();
                }
            }
        });

        document.addEventListener('keyup', (event) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                event.preventDefault();
                delete keysPressed[event.key];
                if (Object.keys(keysPressed).length === 0) {
                    stopMovement();
                }
            }
        });

        // Chat functionality
        chatSend.addEventListener('click', () => {
            const message = chatInput.value.trim();
            if (message.length === 0) return;
            ws.send(JSON.stringify({ type: 'chat', playerId: playerId, password: password, message: message }));
            chatInput.value = '';
        });

        chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                chatSend.click();
            }
        });

        // Error Retry Button
        errorRetryButton.addEventListener('click', () => {
            hideErrorOverlay();
            connectionRefused = false;
            reconnectAttempts = 0;
            joinGame();
        });

        // Function to trigger player hit effect
        function triggerPlayerHitEffect(victimId) {
            // Select the player's DOM element
            const playerElement = playerElements[victimId]?.image;
            if (!playerElement) return;
        
            // Add the 'hit' class to trigger the flash effect
            playerElement.classList.add('hit');

            // Add a glow effect
            playerElement.style.boxShadow = '0 0 25px rgba(255, 0, 0, 0.7)';
        
            // Listen for the end of the animation to remove the 'hit' class and glow
            playerElement.addEventListener('animationend', () => {
                playerElement.classList.remove('hit');
                playerElement.style.boxShadow = '';
            }, { once: true });
        
            // Create an explosion element
            const explosion = document.createElement('div');
            explosion.classList.add('explosion-effect');

            // Append the explosion to the player's cell
            playerElement.parentElement.appendChild(explosion);

            // Play the hit sound
            const hitSound = document.getElementById('hit-sound');
            if (hitSound) {
                hitSound.currentTime = 0;
                hitSound.play();
            }
        
            // Remove the explosion element after the animation completes (e.g., 1.5s)
            setTimeout(() => {
                explosion.remove();
            }, 1500);
        }

    } // Close joinGame function

    window.onload = () => {
        const nicknameOverlay = document.getElementById('nickname-overlay');
        const nicknameInput = document.getElementById('nickname-input');
        const nicknameSubmit = document.getElementById('nickname-submit');

        nicknameSubmit.addEventListener('click', () => {
            nickname = nicknameInput.value.trim();
            if (nickname.length === 0) {
                alert('Please enter a nickname.');
                return;
            }
            // Hide the overlay
            nicknameOverlay.style.display = 'none';
            // Focus on the game area
            joinGame();
        });

        // Allow pressing Enter to submit nickname
        nicknameInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                nicknameSubmit.click();
            }
        });

        // Automatically focus on the nickname input when the overlay appears
        nicknameOverlay.style.display = 'flex';
        nicknameInput.focus();
    };
</script>
</body>
</html>
