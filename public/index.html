<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bomberman Game</title>
    <link rel="icon" href="/favicon.png" type="image/x-icon">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline';
        style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
        font-src 'self' https://fonts.gstatic.com;
        connect-src 'self' ws:;
    ">
    <style>
        body { 
            display: flex; 
            justify-content: center; 
            align-items: center; /* Center vertically */
            height: 100vh; /* Full viewport height */
            margin: 0; /* Remove default margin */
            background: radial-gradient(circle at top left, #0f2027, #203a43, #2c5364); 
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            position: relative;
        }
        #background-universe {
            position: fixed;
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            background: transparent;
            z-index: -2;
            overflow: hidden;
        }
        #background-universe::before, #background-universe::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            background: transparent;
            background-image: radial-gradient(white 1px, transparent 1px);
            background-size: 50px 50px;
            opacity: 0.3;
            animation: moveStars1 100s linear infinite;
        }
        #background-universe::after {
            background-size: 100px 100px;
            opacity: 0.2;
            animation: moveStars2 150s linear infinite;
        }
        @keyframes moveStars1 {
            from { transform: translate(0, 0); }
            to { transform: translate(-50%, -50%); }
        }
        @keyframes moveStars2 {
            from { transform: translate(0, 0); }
            to { transform: translate(-100%, -100%); }
        }
        #game-container { 
            display: flex; 
            flex-direction: row; 
            align-items: flex-start;
            width: 100%;
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
            z-index: 1;
        }
        #chat-container {
            display: flex;
            flex-direction: column;
            width: 250px;
            max-width: 100%;
            margin-right: 20px;
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            color: #00ffff;
            height: 600px;
            flex-direction: column;
        }
        #chat-container h2 {
            margin-bottom: 20px;
            text-align: center;
            color: #00ffff;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px #00ffff;
        }
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        .chat-message {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 8px;
            font-size: 12px;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }
        .chat-message .nickname {
            color: #ff69b4; /* Pink color for nickname */
            font-weight: bold;
        }
        #chat-input-container {
            display: flex;
            gap: 10px;
        }
        #chat-input {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            outline: none;
            box-shadow: 0 0 5px rgba(0,255,255,0.5);
            maxlength: 100;
        }
        #chat-send {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            background-color: #00ffff;
            color: #000;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 5px rgba(0,255,255,0.5);
        }
        #chat-send:hover {
            background-color: #00cccc;
            transform: scale(1.05);
        }
        #game-area { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            flex: 1;
            position: relative;
        }
        #game { 
            display: grid;
            grid-template-columns: repeat(15, 50px);
            grid-template-rows: repeat(15, 50px);
            gap: 2px;
            width: 770px;
            height: 770px;
            background-color: #000;
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            border-radius: 10px;
        }
        /* Define the cell styles */
        .cell {
            width: 50px;
            height: 50px;
            position: relative;
            background-size: cover;
            background-position: center;
            border-radius: 5px;
            transition: transform 0.2s;
        }

        .empty-space { 
            background-color: #0D47A1; 
            box-shadow: inset 0 0 5px #2196F3;
        }

        /* Brick walls and indestructible walls */
        .brick-wall {
            background-image: url('/brick_wall_texture.png');
            background-size: cover;
            animation: pulsate 2s infinite;
        }
        .indestructible-wall {
            background-color: #013220;
            box-shadow: 0 0 10px #00FF99;
            animation: rotateWall 4s linear infinite;
        }

        /* Power-up icons will be images inside the cell */
        .power-up-icon {
            position: absolute;
            width: 30px; /* Adjust size as needed */
            height: 30px;
            top: 10px; /* Center vertically */
            left: 10px; /* Center horizontally */
            z-index: 1;
            pointer-events: none; /* So clicks pass through */
            animation: glow 1.5s ease-in-out infinite alternate;
        }

        /* Adjust player image size and positioning */
        .player {
            position: absolute;
            width: 40px;
            height: 40px;
            z-index: 2;
            top: 5px;
            left: 5px;
            transition: transform 0.1s;
            filter: drop-shadow(0 0 10px #00ffff);
        }

        /* Player name above head */
        .player-name {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            background: transparent;
            color: #00ffff;
            padding: 2px 5px;
            border-radius: 5px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            text-shadow: 0 0 5px #00ffff;
            z-index: 3;
            transition: text-shadow 0.3s, color 0.3s;
        }

        .player-name.first-place {
            color: gold;
            text-shadow: 0 0 10px gold, 0 0 20px gold, 0 0 30px gold;
        }

        /* Flash effect when player is hit */
        .player.hit {
            animation: flash-red 5s;
        }

        @keyframes flash-red {
            0% { filter: brightness(100%); }
            50% { filter: brightness(50%) sepia(100%) hue-rotate(-50deg); }
            100% { filter: brightness(100%); }
        }

        /* Explosion effect */
        .explosion-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 50px;
            height: 50px;
            background-image: url('/explosion_sprite.png'); /* Ensure this sprite exists */
            background-size: cover;
            background-position: center;
            z-index: 3; /* Ensure it's above other elements */
            opacity: 0.7; /* Add transparency */
            pointer-events: none; /* Allow clicks to pass through */
            animation: explode 1s forwards;
        }

        @keyframes explode {
            0% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1.2); }
            100% { opacity: 0; transform: scale(1.5); }
        }

        /* Bomb image size and positioning */
        .bomb {
            position: absolute;
            width: 45px; /* Make the bomb larger than the player */
            height: 45px;
            z-index: 1;
            top: 2.5px; /* Center the bomb vertically */
            left: 2.5px; /* Center the bomb horizontally */
            animation: blinkBomb 1s infinite;
        }

        @keyframes blinkBomb {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #status {
            margin-top: 10px;
            font-size: 18px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        /* Updated styles for the player list */
        #player-list {
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            border: 2px solid #00ffff;
            padding: 20px;
            border-radius: 15px;
            width: 250px;
            max-width: 100%;
            height: 600px;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            color: #00ffff;
            margin-left: 20px;
            display: flex;
            flex-direction: column;
        }
        #player-list h2 {
            margin-bottom: 20px;
            text-align: center;
            color: #00ffff;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px #00ffff;
        }
        #player-list ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
            flex: 1;
        }
        #player-list li {
            margin-bottom: 15px;
            font-size: 16px;
            display: flex;
            align-items: center;
            color: #ffffff;
            text-shadow: 0 0 5px #00ffff;
        }
        #player-list li img.player-icon {
            width: 30px; /* Adjust size of player icon */
            height: 30px;
            margin-right: 5px;
            filter: drop-shadow(0 0 5px #00ffff);
        }
        #player-list li img.trophy {
            width: 40px;
            height: 40px;
            margin-left: 5px;
        }

        /* Styles for the message container and messages */
        #message-container {
            margin-top: 10px;
            width: 100%;
            text-align: left;
            position: relative;
            max-height: 150px;
            overflow-y: auto;
            flex: 0 0 auto;
        }
        .game-message {
            display: block;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            margin: 8px 0;
            border-radius: 8px;
            animation: fadeout 5s forwards;
            font-size: 14px;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
            backdrop-filter: blur(5px);
        }
        @keyframes fadeout {
            0% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(-10px); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        /* Optional: Enhanced styling for hit messages */
        .game-message.hit-message {
            background: rgba(255, 0, 0, 0.8); /* Semi-transparent red background */
            color: #fff;
            font-weight: bold;
            animation: shake 0.5s, fadeout 5s forwards;
            text-shadow: 0 0 10px #ff0000;
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        /* Styles for the nickname overlay */
        #nickname-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it is on top */
            animation: fadeInOverlay 1s ease-in-out forwards;
        }

        @keyframes fadeInOverlay {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #nickname-prompt {
            background: linear-gradient(135deg, #1f4037, #99f2c8);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0,255,255,0.5);
            animation: zoomIn 0.5s ease-in-out forwards;
        }

        @keyframes zoomIn {
            from { transform: scale(0.5); }
            to { transform: scale(1); }
        }

        #nickname-prompt h2 {
            margin-bottom: 25px;
            color: #ffffff;
            font-family: 'Orbitron', sans-serif;
            font-size: 28px;
            text-shadow: 0 0 10px #00ffff;
        }

        #nickname-prompt input {
            width: 80%;
            padding: 15px;
            margin-bottom: 15px;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            outline: none;
            box-shadow: 0 0 10px rgba(0,255,255,0.5);
            animation: glowInput 2s ease-in-out infinite alternate;
        }

        @keyframes glowInput {
            from { box-shadow: 0 0 5px rgba(0,255,255,0.5); }
            to { box-shadow: 0 0 15px rgba(0,255,255,1); }
        }

        #nickname-prompt button {
            padding: 12px 25px;
            border: none;
            background-color: #00ffff; /* Cyan background */
            color: #000;
            border-radius: 10px;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 10px rgba(0,255,255,0.5);
        }

        #nickname-prompt button:hover {
            background-color: #00cccc; /* Darker cyan on hover */
            transform: scale(1.05);
        }

        /* Connection Refused Error Overlay */
        #error-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Higher than other overlays */
            animation: fadeInOverlay 0.5s ease-in-out forwards;
        }

        #error-message-box {
            background: linear-gradient(135deg, #1f4037, #99f2c8);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0,255,255,0.5);
            animation: zoomIn 0.5s ease-in-out forwards;
        }

        #error-message-box h2 {
            margin-bottom: 20px;
            color: #ff4d4d; /* Red color for error */
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            text-shadow: 0 0 10px #ff4d4d;
        }

        #error-message-box p {
            color: #ffffff;
            font-size: 18px;
            text-shadow: 0 0 5px #00ffff;
        }

        #error-message-box button {
            margin-top: 20px;
            padding: 10px 20px;
            border: none;
            background-color: #00ffff;
            color: #000;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 5px rgba(0,255,255,0.5);
        }

        #error-message-box button:hover {
            background-color: #00cccc;
            transform: scale(1.05);
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            #game {
                grid-template-columns: repeat(15, 40px);
                grid-template-rows: repeat(15, 40px);
                width: 620px;
                height: 620px;
            }
            .cell {
                width: 40px;
                height: 40px;
            }
            .player {
                width: 32px;
                height: 32px;
            }
            .bomb {
                width: 36px;
                height: 36px;
            }
            #player-list {
                width: 200px;
                padding: 15px;
            }
            #nickname-prompt {
                padding: 20px;
            }
            #nickname-prompt h2 {
                font-size: 24px;
            }
            #nickname-prompt input {
                width: 90%;
                padding: 12px;
                font-size: 16px;
            }
            #nickname-prompt button {
                padding: 10px 20px;
                font-size: 16px;
            }
        }

        @media (max-width: 768px) {
            #game-container {
                flex-direction: column;
                align-items: center;
                padding: 10px;
            }
            #game {
                grid-template-columns: repeat(15, 30px);
                grid-template-rows: repeat(15, 30px);
                width: 470px;
                height: 470px;
            }
            .cell {
                width: 30px;
                height: 30px;
            }
            .player {
                width: 24px;
                height: 24px;
            }
            .bomb {
                width: 27px;
                height: 27px;
            }
            #player-list {
                width: 100%;
                margin-left: 0;
                margin-top: 20px;
                height: 400px;
            }
            #chat-container {
                width: 100%;
                margin-right: 0;
                margin-bottom: 20px;
                height: 300px;
            }
            #status {
                font-size: 16px;
            }
        }
        
        /* Futuristic Glowing Text */
        .glow-text {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff, 0 0 40px #00ffff;
            font-family: 'Orbitron', sans-serif;
        }

        /* Glowing Buttons */
        button {
            border: none;
            outline: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }
    </style>
    <!-- Google Fonts for Orbitron -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

<div id="background-universe"></div>

<div id="game-container">
    <div id="chat-container">
        <h2>Chat</h2>
        <div id="chat-messages"></div>
        <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Type your message..." maxlength="100">
            <button id="chat-send">SEND</button>
        </div>
    </div>
    <div id="game-area">
        <div id="game"></div>
        <div id="status" class="glow-text">Game started! Use arrow keys to move. Press space to drop a bomb.</div>
    </div>
    <div id="player-list">
        <h2>Players</h2>
        <ul id="players"></ul>
        <h2>Messages</h2>
        <div id="message-container"></div>
    </div>
</div>

<!-- Connection Refused Error Overlay -->
<div id="error-overlay">
    <div id="error-message-box">
        <h2 class="glow-text">Connection Refused</h2>
        <p class="glow-text">Too many connections from your IP. Please close the game on one of the computers on the same network first.</p>
        <button id="error-retry">Retry</button>
    </div>
</div>

<!-- Audio elements for sound effects -->
<audio id="powerup-sound" src="/powerup_sound.mp3"></audio>
<audio id="bomb-explosion-sound" src="/bomb_explosion.mp3"></audio>
<audio id="hit-sound" src="/hit_sound.wav"></audio>

<!-- Nickname Overlay -->
<div id="nickname-overlay">
    <div id="nickname-prompt">
        <h2 class="glow-text">Enter Your Nickname</h2>
        <input type="text" id="nickname-input" maxlength="20" placeholder="Nickname">
        <button id="nickname-submit" class="glow-text">Join Game</button>
    </div>
</div>

<script>
    let ws;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    const reconnectDelay = 3000; // 3 seconds
    const gameElement = document.getElementById('game');
    const statusElement = document.getElementById('status');
    const playerListElement = document.getElementById('players');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    const errorOverlay = document.getElementById('error-overlay');
    const errorRetryButton = document.getElementById('error-retry');

    let map = []; // Will be initialized from server
    let powerUps = {}; // Positions of power-ups

    let playerId;
    let password;
    const players = {};
    const playerImages = {}; // Mapping of playerId to image name
    let nickname;

    let keysPressed = {};
    let movementInterval = null;
    let movementSpeed = 300; // milliseconds per movement step

    let firstPlaceId = null;

    const playerElements = {}; // Cache for player DOM elements

    let connectionRefused = false;

    function escapeHtml(unsafe) {
        return unsafe.replace(/[&<"'>]/g, function(m) {
            switch (m) {
                case '&': return '&amp;';
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '"': return '&quot;';
                case "'": return '&#039;';
                default: return m;
            }
        });
    }

    function initializeGameGrid() {
        gameElement.innerHTML = ''; // Clear existing grid
        for (let row = 0; row < map.length; row++) {
            for (let col = 0; col < map[row].length; col++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');

                if (map[row][col] === 1) {
                    cell.classList.add('brick-wall');
                } else if (map[row][col] === 0) {
                    cell.classList.add('empty-space');
                } else if (map[row][col] === 2) {
                    cell.classList.add('indestructible-wall');
                } else if (map[row][col] === 3) {
                    cell.classList.add('empty-space');

                    // Create an img element for the power-up
                    const powerUpKey = `${col},${row}`;
                    const powerUpType = powerUps[powerUpKey];

                    const powerUpElement = document.createElement('img');
                    powerUpElement.classList.add('power-up-icon');

                    if (powerUpType === 'bombCapacity') {
                        powerUpElement.src = '/power_up_max_bombs.png';
                    } else if (powerUpType === 'blastRadius') {
                        powerUpElement.src = '/power_up_extra_blast_radius.png';
                    } else if (powerUpType === 'speed') {
                        powerUpElement.src = '/speed_powerup.png';
                    }

                    cell.appendChild(powerUpElement);
                }
                gameElement.appendChild(cell);
            }
        }
    }

    function clearAllBombs() {
        const bombElements = document.querySelectorAll('.bomb');
        bombElements.forEach(bomb => bomb.remove());
    }

    function isWalkable(x, y) {
        if (x < 0 || x >= 15 || y < 0 || y >= 15) return false;

        const tile = map[y][x];
        // Check if there's a bomb at this position
        const cell = gameElement.children[y * 15 + x];
        const hasBomb = cell.querySelector('.bomb');
        // Return true if tile is empty, a power-up, and there's no bomb
        return (tile === 0 || tile === 3) && !hasBomb;
    }

    function addOrUpdatePlayerListItem(player) {
        let listItem = playerListElement.querySelector(`li[data-player-id="${player.id}"]`);
        if (listItem) {
            updatePlayerListItem(player, listItem);
        } else {
            listItem = document.createElement('li');
            listItem.setAttribute('data-player-id', player.id);
            listItem.classList.add('glow-text');
            updatePlayerListItem(player, listItem);
            playerListElement.appendChild(listItem);
        }
    }

    function updatePlayerListItem(player, listItem) {
        listItem.innerHTML = ''; // Clear existing content

        // Create player icon
        const playerIcon = document.createElement('img');
        playerIcon.src = `/${playerImages[player.id] || 'default_player'}.png`;
        playerIcon.alt = `Player ${player.playerNumber}`;
        playerIcon.classList.add('player-icon');
        listItem.appendChild(playerIcon);

        // Add trophy based on rank
        const index = Array.from(playerListElement.children).indexOf(listItem);
        if (index === 0) {
            const trophy = document.createElement('img');
            trophy.src = '/tropheegold.png';
            trophy.alt = 'Gold Trophy';
            trophy.classList.add('trophy');
            listItem.appendChild(trophy);
        } else if (index === 1) {
            const trophy = document.createElement('img');
            trophy.src = '/tropheesilver.png';
            trophy.alt = 'Silver Trophy';
            trophy.classList.add('trophy');
            listItem.appendChild(trophy);
        } else if (index === 2) {
            const trophy = document.createElement('img');
            trophy.src = '/tropheebronze.png';
            trophy.alt = 'Bronze Trophy';
            trophy.classList.add('trophy');
            listItem.appendChild(trophy);
        }

        const safeNickname = escapeHtml(player.nickname || `Player ${player.playerNumber || player.id}`);
        const textNode = document.createTextNode(` ${safeNickname}: ${player.score} points`);
        listItem.appendChild(textNode);
    }

    function removePlayerListItem(playerId) {
        const listItem = playerListElement.querySelector(`li[data-player-id="${playerId}"]`);
        if (listItem) {
            listItem.remove();
        }
    }

    function updatePlayerList(playersData) {
        if (!playersData || typeof playersData !== 'object') {
            console.error("Invalid playersData:", playersData);
            return;
        }

        const playersArray = Object.entries(playersData).map(([pid, player]) => ({ id: pid, ...player }));
        // Sort players by score descending
        playersArray.sort((a, b) => b.score - a.score);

        const currentPlayerIds = new Set(playersArray.map(player => player.id));
        const existingPlayerIds = new Set(Array.from(playerListElement.querySelectorAll('li')).map(li => li.getAttribute('data-player-id')));

        // Remove players not in the new list
        existingPlayerIds.forEach(pid => {
            if (!currentPlayerIds.has(pid)) {
                removePlayerListItem(pid);
            }
        });

        // Add or update players
        playersArray.forEach(player => {
            addOrUpdatePlayerListItem(player);
        });

        // Update first place
        // Remove 'first-place' from the previous first player
        if (firstPlaceId) {
            const previousFirstPlayerName = document.querySelector(`.cell .${firstPlaceId}-name`);
            if (previousFirstPlayerName) {
                previousFirstPlayerName.classList.remove('first-place');
            }
        }

        // Update first place player
        const firstPlayer = playersArray[0];
        if (firstPlayer) {
            const newFirstPlayerName = document.querySelector(`.cell .${firstPlayer.id}-name`);
            if (newFirstPlayerName) {
                newFirstPlayerName.classList.add('first-place');
            }
            firstPlaceId = firstPlayer.id;
        }

        // Reorder the list to match the sorted players
        playersArray.forEach((player, index) => {
            const listItem = playerListElement.querySelector(`li[data-player-id="${player.id}"]`);
            if (listItem && playerListElement.children[index] !== listItem) {
                playerListElement.insertBefore(listItem, playerListElement.children[index]);
            }
        });
    }

    function updatePlayerPosition(pid, x, y, direction = 'down') {
        if (!players[pid]) {
            players[pid] = {};
        }

        // Remove existing player sprite and name from cache
        if (playerElements[pid]) {
            playerElements[pid].image.remove();
            playerElements[pid].name.remove();
        }

        // Calculate the index in the grid
        const index = y * 15 + x;
        const cell = gameElement.children[index];

        if (!cell) {
            console.error(`Cell at index ${index} is undefined. x: ${x}, y: ${y}`);
            return;
        }

        // Map 'ArrowUp' to 'up', etc.
        const directionMap = {
            'ArrowUp': 'up',
            'ArrowDown': 'down',
            'ArrowLeft': 'left',
            'ArrowRight': 'right'
        };

        const mappedDirection = directionMap[direction] || direction;

        const playerElement = document.createElement('img');
        // Use the mapped image name
        const imageName = playerImages[pid] ? playerImages[pid] : 'default_player';
        playerElement.src = `/${imageName}_${mappedDirection}.png`;
        playerElement.classList.add('player', pid, 'glow-text');
        cell.appendChild(playerElement);

        // Add player name
        const playerName = document.createElement('div');
        playerName.classList.add('player-name', `${pid}-name`);
        playerName.textContent = players[pid].nickname || `Player ${players[pid].playerNumber || pid}`;
        cell.appendChild(playerName);

        // If this player is first place, add the 'first-place' class
        if (pid === firstPlaceId) {
            playerName.classList.add('first-place');
        }

        // Cache the player elements
        playerElements[pid] = {
            image: playerElement,
            name: playerName
        };

        // Update local player state
        players[pid].x = x;
        players[pid].y = y;
        players[pid].direction = mappedDirection;
    }

    function removePlayer(pid) {
        if (playerElements[pid]) {
            playerElements[pid].image.remove();
            playerElements[pid].name.remove();
            delete playerElements[pid];
        }
        delete players[pid];
    }

    function placeBomb(x, y) {
        const index = y * 15 + x;
        const cell = gameElement.children[index];

        if (!cell) {
            console.error(`Cell at index ${index} is undefined. x: ${x}, y: ${y}`);
            return;
        }

        const bombElement = document.createElement('img');
        bombElement.src = '/bomb_sprite.png';
        bombElement.classList.add('bomb', 'glow-text');
        cell.appendChild(bombElement);
    }

    function explodeBomb(x, y, destroyedBricks, newPowerUps, explosionPositions) {
        // Remove bomb sprite at the center
        const index = y * 15 + x;
        const cell = gameElement.children[index];
        const bombElement = cell.querySelector('.bomb');
        if (bombElement) {
            bombElement.remove();
        }

        // Play bomb explosion sound
        const bombExplosionSound = document.getElementById('bomb-explosion-sound');
        if (bombExplosionSound) {
            bombExplosionSound.currentTime = 0; // Rewind to start
            bombExplosionSound.play();
        }

        // Display explosion effect in all positions
        explosionPositions.forEach(pos => {
            const idx = pos.y * 15 + pos.x;
            const explosionCell = gameElement.children[idx];

            if (!explosionCell) {
                console.error(`Cell at index ${idx} is undefined. x: ${pos.x}, y: ${pos.y}`);
                return;
            }

            // Display explosion effect
            displayExplosion(explosionCell);

            // If the tile was a brick wall, update it
            if (map[pos.y][pos.x] === 1) {
                map[pos.y][pos.x] = 0;
                explosionCell.classList.remove('brick-wall');
                explosionCell.classList.add('empty-space');
            }

            // Remove bomb sprites in the explosion area
            const bombInCell = explosionCell.querySelector('.bomb');
            if (bombInCell) {
                bombInCell.remove();
            }
        });

        // Handle new power-ups
        newPowerUps.forEach(powerUp => {
            const idx = powerUp.y * 15 + powerUp.x;
            const powerUpCell = gameElement.children[idx];
            const powerUpKey = `${powerUp.x},${powerUp.y}`;
            powerUps[powerUpKey] = powerUp.type; // Update powerUps object
            map[powerUp.y][powerUp.x] = 0; // Update map array

            // Remove any existing classes (e.g., empty-space)
            powerUpCell.className = 'cell empty-space';

            // Create an img element for the power-up icon
            const powerUpElement = document.createElement('img');
            powerUpElement.classList.add('power-up-icon');

            if (powerUp.type === 'bombCapacity') {
                powerUpElement.src = '/power_up_max_bombs.png';
            } else if (powerUp.type === 'blastRadius') {
                powerUpElement.src = '/power_up_extra_blast_radius.png';
            } else if (powerUp.type === 'speed') {
                powerUpElement.src = '/speed_powerup.png';
            }

            powerUpCell.appendChild(powerUpElement);
        });
    }

    function displayExplosion(cell) {
        const explosionElement = document.createElement('div');
        explosionElement.classList.add('explosion-effect');
        cell.appendChild(explosionElement);
        setTimeout(() => {
            explosionElement.remove();
        }, 1000);
    }

    function updatePlayerList(playersData) {
        if (!playersData || typeof playersData !== 'object') {
            console.error("Invalid playersData:", playersData);
            return;
        }

        const playersArray = Object.entries(playersData).map(([pid, player]) => ({ id: pid, ...player }));
        // Sort players by score descending
        playersArray.sort((a, b) => b.score - a.score);

        const currentPlayerIds = new Set(playersArray.map(player => player.id));
        const existingPlayerIds = new Set(Array.from(playerListElement.querySelectorAll('li')).map(li => li.getAttribute('data-player-id')));

        // Remove players not in the new list
        existingPlayerIds.forEach(pid => {
            if (!currentPlayerIds.has(pid)) {
                removePlayerListItem(pid);
            }
        });

        // Add or update players
        playersArray.forEach(player => {
            addOrUpdatePlayerListItem(player);
        });

        // Update first place
        // Remove 'first-place' from the previous first player
        if (firstPlaceId) {
            const previousFirstPlayerName = document.querySelector(`.cell .${firstPlaceId}-name`);
            if (previousFirstPlayerName) {
                previousFirstPlayerName.classList.remove('first-place');
            }
        }

        // Update first place player
        const firstPlayer = playersArray[0];
        if (firstPlayer) {
            const newFirstPlayerName = document.querySelector(`.cell .${firstPlayer.id}-name`);
            if (newFirstPlayerName) {
                newFirstPlayerName.classList.add('first-place');
            }
            firstPlaceId = firstPlayer.id;
        }

        // Reorder the list to match the sorted players
        playersArray.forEach((player, index) => {
            const listItem = playerListElement.querySelector(`li[data-player-id="${player.id}"]`);
            if (listItem && playerListElement.children[index] !== listItem) {
                playerListElement.insertBefore(listItem, playerListElement.children[index]);
            }
        });
    }

    function updatePlayerPosition(pid, x, y, direction = 'down') {
        if (!players[pid]) {
            players[pid] = {};
        }

        // Remove existing player sprite and name from cache
        if (playerElements[pid]) {
            playerElements[pid].image.remove();
            playerElements[pid].name.remove();
        }

        // Calculate the index in the grid
        const index = y * 15 + x;
        const cell = gameElement.children[index];

        if (!cell) {
            console.error(`Cell at index ${index} is undefined. x: ${x}, y: ${y}`);
            return;
        }

        // Map 'ArrowUp' to 'up', etc.
        const directionMap = {
            'ArrowUp': 'up',
            'ArrowDown': 'down',
            'ArrowLeft': 'left',
            'ArrowRight': 'right'
        };

        const mappedDirection = directionMap[direction] || direction;

        const playerElement = document.createElement('img');
        // Use the mapped image name
        const imageName = playerImages[pid] ? playerImages[pid] : 'default_player';
        playerElement.src = `/${imageName}_${mappedDirection}.png`;
        playerElement.classList.add('player', pid, 'glow-text');
        cell.appendChild(playerElement);

        // Add player name
        const playerName = document.createElement('div');
        playerName.classList.add('player-name', `${pid}-name`);
        playerName.textContent = players[pid].nickname || `Player ${players[pid].playerNumber || pid}`;
        cell.appendChild(playerName);

        // If this player is first place, add the 'first-place' class
        if (pid === firstPlaceId) {
            playerName.classList.add('first-place');
        }

        // Cache the player elements
        playerElements[pid] = {
            image: playerElement,
            name: playerName
        };

        // Update local player state
        players[pid].x = x;
        players[pid].y = y;
        players[pid].direction = mappedDirection;
    }

    function removePlayer(pid) {
        if (playerElements[pid]) {
            playerElements[pid].image.remove();
            playerElements[pid].name.remove();
            delete playerElements[pid];
        }
        delete players[pid];
    }

    function placeBomb(x, y) {
        const index = y * 15 + x;
        const cell = gameElement.children[index];

        if (!cell) {
            console.error(`Cell at index ${index} is undefined. x: ${x}, y: ${y}`);
            return;
        }

        const bombElement = document.createElement('img');
        bombElement.src = '/bomb_sprite.png';
        bombElement.classList.add('bomb', 'glow-text');
        cell.appendChild(bombElement);
    }

    function explodeBomb(x, y, destroyedBricks, newPowerUps, explosionPositions) {
        // Remove bomb sprite at the center
        const index = y * 15 + x;
        const cell = gameElement.children[index];
        const bombElement = cell.querySelector('.bomb');
        if (bombElement) {
            bombElement.remove();
        }

        // Play bomb explosion sound
        const bombExplosionSound = document.getElementById('bomb-explosion-sound');
        if (bombExplosionSound) {
            bombExplosionSound.currentTime = 0; // Rewind to start
            bombExplosionSound.play();
        }

        // Display explosion effect in all positions
        explosionPositions.forEach(pos => {
            const idx = pos.y * 15 + pos.x;
            const explosionCell = gameElement.children[idx];

            if (!explosionCell) {
                console.error(`Cell at index ${idx} is undefined. x: ${pos.x}, y: ${pos.y}`);
                return;
            }

            // Display explosion effect
            displayExplosion(explosionCell);

            // If the tile was a brick wall, update it
            if (map[pos.y][pos.x] === 1) {
                map[pos.y][pos.x] = 0;
                explosionCell.classList.remove('brick-wall');
                explosionCell.classList.add('empty-space');
            }

            // Remove bomb sprites in the explosion area
            const bombInCell = explosionCell.querySelector('.bomb');
            if (bombInCell) {
                bombInCell.remove();
            }
        });

        // Handle new power-ups
        newPowerUps.forEach(powerUp => {
            const idx = powerUp.y * 15 + powerUp.x;
            const powerUpCell = gameElement.children[idx];
            const powerUpKey = `${powerUp.x},${powerUp.y}`;
            powerUps[powerUpKey] = powerUp.type; // Update powerUps object
            map[powerUp.y][powerUp.x] = 0; // Update map array

            // Remove any existing classes (e.g., empty-space)
            powerUpCell.className = 'cell empty-space';

            // Create an img element for the power-up icon
            const powerUpElement = document.createElement('img');
            powerUpElement.classList.add('power-up-icon');

            if (powerUp.type === 'bombCapacity') {
                powerUpElement.src = '/power_up_max_bombs.png';
            } else if (powerUp.type === 'blastRadius') {
                powerUpElement.src = '/power_up_extra_blast_radius.png';
            } else if (powerUp.type === 'speed') {
                powerUpElement.src = '/speed_powerup.png';
            }

            powerUpCell.appendChild(powerUpElement);
        });
    }

    function displayExplosion(cell) {
        const explosionElement = document.createElement('div');
        explosionElement.classList.add('explosion-effect');
        cell.appendChild(explosionElement);
        setTimeout(() => {
            explosionElement.remove();
        }, 1000);
    }

    function updatePlayerList(playersData) {
        if (!playersData || typeof playersData !== 'object') {
            console.error("Invalid playersData:", playersData);
            return;
        }

        const playersArray = Object.entries(playersData).map(([pid, player]) => ({ id: pid, ...player }));
        // Sort players by score descending
        playersArray.sort((a, b) => b.score - a.score);

        const currentPlayerIds = new Set(playersArray.map(player => player.id));
        const existingPlayerIds = new Set(Array.from(playerListElement.querySelectorAll('li')).map(li => li.getAttribute('data-player-id')));

        // Remove players not in the new list
        existingPlayerIds.forEach(pid => {
            if (!currentPlayerIds.has(pid)) {
                removePlayerListItem(pid);
            }
        });

        // Add or update players
        playersArray.forEach(player => {
            addOrUpdatePlayerListItem(player);
        });

        // Update first place
        // Remove 'first-place' from the previous first player
        if (firstPlaceId) {
            const previousFirstPlayerName = document.querySelector(`.cell .${firstPlaceId}-name`);
            if (previousFirstPlayerName) {
                previousFirstPlayerName.classList.remove('first-place');
            }
        }

        // Update first place player
        const firstPlayer = playersArray[0];
        if (firstPlayer) {
            const newFirstPlayerName = document.querySelector(`.cell .${firstPlayer.id}-name`);
            if (newFirstPlayerName) {
                newFirstPlayerName.classList.add('first-place');
            }
            firstPlaceId = firstPlayer.id;
        }

        // Reorder the list to match the sorted players
        playersArray.forEach((player, index) => {
            const listItem = playerListElement.querySelector(`li[data-player-id="${player.id}"]`);
            if (listItem && playerListElement.children[index] !== listItem) {
                playerListElement.insertBefore(listItem, playerListElement.children[index]);
            }
        });
    }

    function startMovement() {
        if (movementInterval) return;
        movementInterval = setInterval(() => {
            if (Object.keys(keysPressed).length === 0) {
                stopMovement();
                return;
            }
            let direction = null;
            if (keysPressed['ArrowUp']) direction = 'ArrowUp';
            else if (keysPressed['ArrowDown']) direction = 'ArrowDown';
            else if (keysPressed['ArrowLeft']) direction = 'ArrowLeft';
            else if (keysPressed['ArrowRight']) direction = 'ArrowRight';

            if (direction) {
                // Calculate new position
                let newX = players[playerId].x;
                let newY = players[playerId].y;

                if (direction === 'ArrowUp') newY--;
                if (direction === 'ArrowDown') newY++;
                if (direction === 'ArrowLeft') newX--;
                if (direction === 'ArrowRight') newX++;

                if (isWalkable(newX, newY)) {
                    // Send move message
                    ws.send(JSON.stringify({ type: 'move', direction: direction, playerId: playerId, password: password }));
                }
            }
        }, movementSpeed);
    }

    function stopMovement() {
        if (movementInterval) {
            clearInterval(movementInterval);
            movementInterval = null;
        }
    }

    function updatePlayerSpeed() {
        const player = players[playerId];
        if (!player) return;

        if (player.speed === 1) {
            movementSpeed = 250;
        } else if (player.speed === 2) {
            movementSpeed = 219;
        } else if (player.speed === 3) {
            movementSpeed = 188;
        } else if (player.speed >= 4) {
            movementSpeed = 156;
        }
        // Restart movement interval to apply new speed
        if (movementInterval) {
            stopMovement();
            startMovement();
        }
    }

    function showMessage(text) {
        const messageContainer = document.getElementById('message-container');
        const messageElement = document.createElement('div');
        messageElement.classList.add('game-message');
        messageElement.textContent = text;
        
        // Add a special class for hit messages
        if (text.includes('hit') || text.includes('blew yourself up')) {
            messageElement.classList.add('hit-message');
        }
        
        messageContainer.appendChild(messageElement);
        
        // Remove the message after some time
        setTimeout(() => {
            messageElement.remove();
        }, 5000); // Display message for 5 seconds
    }

    function showErrorOverlay() {
        errorOverlay.style.display = 'flex';
    }

    function hideErrorOverlay() {
        errorOverlay.style.display = 'none';
    }

    function joinGame() {
        // Extract password from URL
        const urlParts = window.location.pathname.split('/');
        password = urlParts[urlParts.length - 1];

        // Retrieve or generate a unique playerId using sessionStorage
        playerId = sessionStorage.getItem('playerId');
        if (!playerId) {
            playerId = 'player-' + Math.random().toString(36).substr(2, 9);
            sessionStorage.setItem('playerId', playerId);
        }

        if (ws && ws.readyState !== WebSocket.CLOSED) {
            ws.close();
        }

        // Determine the correct WebSocket protocol
        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        ws = new WebSocket(`${protocol}://${window.location.host}`);
        ws.onopen = () => {
            ws.send(JSON.stringify({ type: 'join', playerId: playerId, password: password, nickname: nickname }));
            reconnectAttempts = 0;
            statusElement.textContent = "Connected to Bomberman!";
        };

        ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            if (message.type === 'start') {
                // Store your player number
                if (message.playerNumber) {
                    const imageName = message.playerNumber ? `player${message.playerNumber}` : 'default_player';
                    playerImages[playerId] = imageName;
                }

                // Initialize map and power-ups
                map = message.map;
                powerUps = {};
                message.powerUps.forEach(powerUp => {
                    const powerUpKey = `${powerUp.x},${powerUp.y}`;
                    powerUps[powerUpKey] = powerUp.type;
                });
                initializeGameGrid();

                // Update positions of all players
                for (const pid in message.players) {
                    const player = message.players[pid];
                    // Map other players' IDs to image names
                    const imageName = player.playerNumber ? `player${player.playerNumber}` : 'default_player';
                    playerImages[pid] = imageName;
                    updatePlayerPosition(pid, player.x, player.y, 'down');
                    players[pid] = players[pid] || {};
                    players[pid].speed = player.speed || 1;
                    players[pid].nickname = player.nickname || `Player ${player.playerNumber || pid}`;
                }

                // Update player list
                if (message.players && typeof message.players === 'object') {
                    updatePlayerList(message.players);
                }

                // Update movement speed
                updatePlayerSpeed();

            } else if (message.type === 'newMap') {
                // Clear existing bombs
                clearAllBombs();

                // Handle new map
                map = message.map;
                powerUps = {};
                if (message.powerUps && Array.isArray(message.powerUps)) {
                    message.powerUps.forEach(powerUp => {
                        const powerUpKey = `${powerUp.x},${powerUp.y}`;
                        powerUps[powerUpKey] = powerUp.type;
                    });
                }
                initializeGameGrid();

                // Update players' positions and reset local player properties
                if (message.players && typeof message.players === 'object') {
                    for (const pid in message.players) {
                        const player = message.players[pid];
                        const imageName = player.playerNumber ? `player${player.playerNumber}` : 'default_player';
                        playerImages[pid] = imageName;
                        players[pid] = players[pid] || {};
                        players[pid].x = player.x;
                        players[pid].y = player.y;
                        players[pid].speed = player.speed || 1;
                        players[pid].nickname = player.nickname || `Player ${player.playerNumber || pid}`;
                        updatePlayerPosition(pid, player.x, player.y, 'down');
                    }

                    // Update movement speed
                    updatePlayerSpeed();

                    // Update player list
                    updatePlayerList(message.players);

                    // Show the new map message
                    showMessage("A new map has been generated!");
                } else {
                    console.error("Invalid playersData in newMap:", message.players);
                }
            } else if (message.type === 'update') {
                if (message.playerId && typeof message.x === 'number' && typeof message.y === 'number') {
                    updatePlayerPosition(message.playerId, message.x, message.y, message.direction);
                    if (message.players && typeof message.players === 'object') {
                        updatePlayerList(message.players);
                    }
                }
            } else if (message.type === 'newPlayer') {
                // Map new player's ID to image names
                const newPlayerId = message.playerId;
                const imageName = message.playerNumber ? `player${message.playerNumber}` : 'default_player';
                playerImages[newPlayerId] = imageName;
                updatePlayerPosition(newPlayerId, message.x, message.y, 'down');

                // Store nickname
                players[newPlayerId] = players[newPlayerId] || {};
                players[newPlayerId].nickname = message.nickname || `Player ${message.playerNumber || newPlayerId}`;

                // Update player list
                if (message.players && typeof message.players === 'object') {
                    updatePlayerList(message.players);
                }

            } else if (message.type === 'playerLeft') {
                if (message.playerId) {
                    removePlayer(message.playerId);
                }
                // Update player list
                if (message.players && typeof message.players === 'object') {
                    updatePlayerList(message.players);
                }
            } else if (message.type === 'bombPlaced') {
                if (typeof message.x === 'number' && typeof message.y === 'number') {
                    placeBomb(message.x, message.y);
                }
            } else if (message.type === 'bombExploded') {
                if (typeof message.x === 'number' && typeof message.y === 'number' &&
                    Array.isArray(message.destroyedBricks) && Array.isArray(message.newPowerUps) &&
                    Array.isArray(message.explosionPositions)) {
                    explodeBomb(
                        message.x,
                        message.y,
                        message.destroyedBricks,
                        message.newPowerUps,
                        message.explosionPositions
                    );
                }
            } else if (message.type === 'playerHit') {
                const victimId = message.playerId;
                const attackerId = message.by;
                const victimNickname = players[victimId] ? escapeHtml(players[victimId].nickname || `Player ${players[victimId].playerNumber || victimId}`) : 'Unknown';
                const attackerNickname = attackerId && players[attackerId] ? escapeHtml(players[attackerId].nickname || `Player ${attackerId}`) : 'Unknown';
                
                // Update player position
                if (message.x !== undefined && message.y !== undefined) {
                    updatePlayerPosition(victimId, message.x, message.y, 'down');
                }
                
                // Display appropriate message
                if (victimId === playerId) {
                    if (attackerId === playerId) {
                        showMessage(`You blew yourself up!`);
                    } else {
                        showMessage(`You were hit by ${attackerNickname}!`);
                    }
                } else {
                    if (attackerId === victimId) {
                        showMessage(`${victimNickname} blew themselves up!`);
                    } else {
                        showMessage(`${victimNickname} was hit by ${attackerNickname}!`);
                    }
                }
                
                // Trigger visual effects for the victim
                triggerPlayerHitEffect(victimId);

                // Update player list in case scores changed
                if (message.players && typeof message.players === 'object') {
                    updatePlayerList(message.players);
                }
            } else if (message.type === 'powerUpCollected') {
                if (typeof message.x === 'number' && typeof message.y === 'number') {
                    const idx = message.y * 15 + message.x;
                    const cell = gameElement.children[idx];
                    const powerUpKey = `${message.x},${message.y}`;
                    delete powerUps[powerUpKey]; // Remove from powerUps object
                    map[message.y][message.x] = 0; // Update map array

                    // Remove power-up icon from the cell
                    const powerUpElement = cell.querySelector('.power-up-icon');
                    if (powerUpElement) {
                        powerUpElement.remove();
                    }

                    // Play power-up sound
                    const powerupSound = document.getElementById('powerup-sound');
                    if (powerupSound) {
                        powerupSound.currentTime = 0;
                        powerupSound.play();
                    }
                }
            } else if (message.type === 'chat') {
                if (message.nickname && message.message) {
                    const chatMsg = document.createElement('div');
                    chatMsg.classList.add('chat-message');

                    const nicknameSpan = document.createElement('span');
                    nicknameSpan.classList.add('nickname');
                    nicknameSpan.textContent = `${message.nickname}: `;

                    chatMsg.appendChild(nicknameSpan);
                    chatMsg.appendChild(document.createTextNode(message.message));

                    chatMessages.appendChild(chatMsg);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            } else if (message.type === 'updatePlayerList') {
                if (message.players && typeof message.players === 'object') {
                    updatePlayerList(message.players);
                    // Update player's speed
                    if (players[playerId] && message.players[playerId]) {
                        players[playerId].speed = message.players[playerId].speed || 1;
                        updatePlayerSpeed();
                    }
                }
            }
            // Handle other message types as needed
        };

        // Error handling for WebSocket
        ws.onerror = (error) => console.error("WebSocket error:", error);

        ws.onclose = (event) => {
            if (event.code === 4001) { // Maximum connections per IP exceeded
                connectionRefused = true;
                showErrorOverlay();
            } else {
                if (reconnectAttempts < maxReconnectAttempts && !connectionRefused) {
                    reconnectAttempts++;
                    setTimeout(joinGame, reconnectDelay * Math.pow(2, reconnectAttempts));
                } else {
                    console.error("Max reconnection attempts reached.");
                    statusElement.textContent = "Connection lost. Unable to reconnect.";
                }
            }
        };

        // Event listeners for key presses
        document.addEventListener('keydown', (event) => {
            // Check if chat input is focused
            if (document.activeElement === chatInput) {
                return;
            }

            if (event.key === ' ') {
                event.preventDefault();
                // Send placeBomb message
                ws.send(JSON.stringify({ type: 'placeBomb', playerId: playerId, password: password }));
            } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                if (!keysPressed[event.key]) {
                    event.preventDefault();
                    keysPressed[event.key] = true;
                    // Send move immediately
                    ws.send(JSON.stringify({ type: 'move', direction: event.key, playerId: playerId, password: password }));
                    startMovement();
                }
            }
        });

        document.addEventListener('keyup', (event) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                event.preventDefault();
                delete keysPressed[event.key];
                if (Object.keys(keysPressed).length === 0) {
                    stopMovement();
                }
            }
        });

        // Chat functionality
        chatSend.addEventListener('click', () => {
            const message = chatInput.value.trim();
            if (message.length === 0) return;
            ws.send(JSON.stringify({ type: 'chat', playerId: playerId, password: password, message: message }));
            chatInput.value = '';
        });

        chatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                chatSend.click();
            }
        });

        // Error Retry Button
        errorRetryButton.addEventListener('click', () => {
            hideErrorOverlay();
            connectionRefused = false;
            reconnectAttempts = 0;
            joinGame();
        });

        // Function to trigger player hit effect
        function triggerPlayerHitEffect(victimId) {
            // Select the player's DOM element
            const playerElement = playerElements[victimId]?.image;
            if (!playerElement) return;
        
            // Add the 'hit' class to trigger the flash effect
            playerElement.classList.add('hit');

            // Add a glow effect
            playerElement.style.boxShadow = '0 0 20px rgba(255, 0, 0, 0.7)';
        
            // Listen for the end of the animation to remove the 'hit' class and glow
            playerElement.addEventListener('animationend', () => {
                playerElement.classList.remove('hit');
                playerElement.style.boxShadow = '';
            }, { once: true });
        
            // Create an explosion element
            const explosion = document.createElement('div');
            explosion.classList.add('explosion-effect');

            // Append the explosion to the player's cell
            playerElement.parentElement.appendChild(explosion);

            // Play the hit sound
            const hitSound = document.getElementById('hit-sound');
            if (hitSound) {
                hitSound.currentTime = 0;
                hitSound.play();
            }
        
            // Remove the explosion element after the animation completes (e.g., 1s)
            setTimeout(() => {
                explosion.remove();
            }, 1000);
        }

    } // Close joinGame function

    window.onload = () => {
        const nicknameOverlay = document.getElementById('nickname-overlay');
        const nicknameInput = document.getElementById('nickname-input');
        const nicknameSubmit = document.getElementById('nickname-submit');

        nicknameSubmit.addEventListener('click', () => {
            nickname = nicknameInput.value.trim();
            if (nickname.length === 0) {
                alert('Please enter a nickname.');
                return;
            }
            // Hide the overlay
            nicknameOverlay.style.display = 'none';
            // Focus on the game area
            joinGame();
        });

        // Allow pressing Enter to submit nickname
        nicknameInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                nicknameSubmit.click();
            }
        });

        // Automatically focus on the nickname input when the overlay appears
        nicknameOverlay.style.display = 'flex';
        nicknameInput.focus();
    };
</script>
</body>
</html>
